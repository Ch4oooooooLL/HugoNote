[{"content":"1. 问题定义与物理模型 目标：求解一根长度为 $L$、弹性模量为 $E$、横截面积 $A(x)$ 随位置变化的杆件，在右端受到拉力 $P$ 作用下的位移场 $u(x)$。\n控制方程 (Strong Form)： $$ \\frac{d}{dx}\\left( E A(x) \\frac{du}{dx} \\right) = 0, \\quad x \\in [0, L] $$ 边界条件：\nDirichlet (本质边界): $u(0) = 0$ (左端固定) Neumann (自然边界): $E A(L) \\frac{du}{dx}|_{x=L} = P$ (右端受力) 有限元离散 (Weak Form)： 对于线性杆单元，单元刚度矩阵 $k_e$ 为： $$ k_e = \\frac{EA_{avg}}{L_e} \\begin{bmatrix} 1 \u0026 -1 \\\\ -1 \u0026 1 \\end{bmatrix} $$ 其中 $A_{avg}$ 取单元中心处的截面面积近似。\n2. 代码实现架构 程序整体分为五个模块：\n前处理 (Pre-processing): 离散化几何域，生成节点与单元。 单元计算 (Element Calculation): 计算局部刚度矩阵。 组装 (Assembly): 构建全局刚度矩阵 $K$ 和载荷向量 $F$。 边界处理 (Boundary Conditions): 修正矩阵以引入约束。 求解与可视化 (Solver \u0026amp; Post-processing): 解方程组并绘图。 2.1 初始化与参数定义 import numpy as np import matplotlib.pyplot as plt # === 物理参数 === L_total = 10.0 # 杆件总长度 [m] P_load = 1000.0 # 末端拉力 [N] E_mod = 2.1e11 # 弹性模量 [Pa] # === 几何参数 (变截面模拟) === def get_area(x): \u0026#34;\u0026#34;\u0026#34; 定义横截面积 A 随坐标 x 的变化函数 此处模拟锥形杆: 根部 0.01 m^2 -\u0026gt; 末端 0.005 m^2 \u0026#34;\u0026#34;\u0026#34; return 0.01 - (0.005 * x / L_total) # === 网格控制 === NUM_ELEMENTS = 10 # 单元数量 NUM_NODES = NUM_ELEMENTS + 1 # 节点数量 (1D线性单元) 2.2 网格生成 (Meshing) Nodes (Coordinates): 存储物理坐标。 Connectivity (Topology): 存储节点间的连接关系。对于 1D 线性单元，第 $i$ 个单元连接节点 $i$ 和 $i+1$。 # 1. 生成节点坐标数组 # linspace: 生成等间距分布的节点 nodes = np.linspace(0, L_total, NUM_NODES) # 2. 生成单元连接表 (Connectivity Matrix) # elements[i] = [左节点索引, 右节点索引] elements = [] for i in range(NUM_ELEMENTS): elements.append([i, i + 1]) # 转为 array 方便后续索引 elements = np.array(elements) np.linspace(start, stop, num) 生成包含 num 个点的等差数列（闭区间）。这是 FEM 生成结构化网格最常用的函数。\n2.3 单元刚度矩阵与全局组装 此部分是 FEM 算法核心。\n局部近似: 假定单元内部属性均匀，取中点面积 $A_{mid}$ 计算 $k_e$。 自由度映射 (DOF Mapping): 局部索引 0 (左) $\\rightarrow$ 全局索引 node_i 局部索引 1 (右) $\\rightarrow$ 全局索引 node_j 累加: 全局矩阵 $K_{global}$ 的对应位置累加局部矩阵的分量。 # 初始化全局矩阵 (使用稠密矩阵，大规模问题需改用 scipy.sparse) K_global = np.zeros((NUM_NODES, NUM_NODES)) F_global = np.zeros(NUM_NODES) print(\u0026#34;开始组装刚度矩阵...\u0026#34;) for e in range(NUM_ELEMENTS): # --- Step 1: 获取拓扑信息 --- # 获取当前单元连接的全局节点索引 idx_L = elements[e, 0] # 左节点 Global ID idx_R = elements[e, 1] # 右节点 Global ID # 获取节点物理坐标 x_L = nodes[idx_L] x_R = nodes[idx_R] # --- Step 2: 计算单元刚度矩阵 k_e --- # 单元长度 Le = x_R - x_L # 单元中点坐标 -\u0026gt; 计算中点面积 (变截面近似处理) x_mid = (x_L + x_R) / 2.0 A_avg = get_area(x_mid) # 刚度系数 k = EA/L k_val = E_mod * A_avg / Le # 局部刚度矩阵 (2x2) # [ k, -k] # [-k, k] k_element = k_val * np.array([[1, -1], [-1, 1]]) # --- Step 3: 组装到全局矩阵 (Scatter) --- # 映射关系: # local [0, 0] -\u0026gt; global [idx_L, idx_L] # local [0, 1] -\u0026gt; global [idx_L, idx_R] ... K_global[idx_L, idx_L] += k_element[0, 0] K_global[idx_L, idx_R] += k_element[0, 1] K_global[idx_R, idx_L] += k_element[1, 0] K_global[idx_R, idx_R] += k_element[1, 1] print(\u0026#34;组装完成。\u0026#34;) 2.4 施加边界条件 (Boundary Conditions) 原始 $K_{global}$ 是奇异矩阵（行列式为 0），代表结构存在刚体位移模式。必须引入 Dirichlet 边界条件才能求解。\n目标：强制 $u_{node} = \\bar{u}$。 操作：\n将 $K$ 中对应 行 全部置零。 将对角线元素 $K_{ii}$ 置为 1。 将 $F$ 中对应元素 $F_i$ 置为 $\\bar{u}$。 注：为了保持对称性，通常也可将对应 列 置零，但这步对于非对称求解器不是必须的。 # 复制矩阵以保留原始数据（良好的编程习惯） K_final = K_global.copy() F_final = F_global.copy() # 1. 施加 Neumann 边界 (力边界) # 在最右端节点 (索引 -1) 施加拉力 P F_final[-1] += P_load # 2. 施加 Dirichlet 边界 (位移边界) # 约束: 左端节点 (索引 0) 位移为 0 fixed_node = 0 fixed_val = 0.0 # (1) 行清零 K_final[fixed_node, :] = 0.0 # (2) 对角线置1 K_final[fixed_node, fixed_node] = 1.0 # (3) 修正载荷项 F_final[fixed_node] = fixed_val # (可选) 对称化处理：列清零 # 注意：若执行列清零，需修正 RHS 向量中受该节点影响的其他项 # F_final -= K_global[:, fixed_node] * fixed_val # 但由于此处 fixed_val=0，此步可省略。 array[i, :] = 0 表示将第 i 行的所有列元素赋值为 0。这是 Numpy 进行矩阵操作的核心语法。\n2.5 求解与后处理 # === 求解线性方程组 Ax = b === # U 为位移向量 U = np.linalg.solve(K_final, F_final) # === 理论解对比 (Exact Solution) === # 对于变截面杆，理论解需积分: u(x) = Integral(P / (E*A(x)) dx) # 简单的数值积分用于对比 x_fine = np.linspace(0, L_total, 100) u_exact = np.zeros_like(x_fine) for i in range(1, len(x_fine)): # 简单的梯形积分 x_seg = x_fine[i] # 近似计算 u = Integral(P/EA) # 这里仅做粗略对比示意 dx = x_fine[i] - x_fine[i-1] mid_A = get_area((x_fine[i] + x_fine[i-1])/2) du = (P_load / (E_mod * mid_A)) * dx u_exact[i] = u_exact[i-1] + du # === 绘图 === plt.figure(figsize=(10, 6)) # 绘制 FEM 结果 plt.plot(nodes, U, \u0026#39;o-\u0026#39;, label=\u0026#39;FEM (Numerical)\u0026#39;, linewidth=2, markersize=8) # 绘制理论近似 plt.plot(x_fine, u_exact, \u0026#39;r--\u0026#39;, label=\u0026#39;Theoretical (Approx)\u0026#39;, alpha=0.7) plt.title(f\u0026#39;1D Variable Cross-section Bar Analysis\\nElements: {NUM_ELEMENTS}\u0026#39;) plt.xlabel(\u0026#39;Position x [m]\u0026#39;) plt.ylabel(\u0026#39;Displacement u [m]\u0026#39;) plt.grid(True, which=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;, alpha=0.6) plt.legend() plt.tight_layout() plt.show() print(f\u0026#34;最大位移 (FEM): {U[-1]:.6e} m\u0026#34;) 3. 复习要点总结 3.1 核心算法复盘 离散化：连续 $\\rightarrow$ 离散 (linspace, connectivity)。 局部刚度：$k = \\frac{EA}{L}$，物理属性在此处通过 $A(x)$ 函数离散化。 组装映射：这是 FEM 编程最容易出错的地方。必须清楚局部索引（0,1）如何对应到全局索引（$i, i+1$）。 边界处理：理解为什么 $K$ 是奇异的，以及置 1 法如何通过数学手段消除刚体位移。 3.2 Python 科学计算语法速查 语法 说明 示例 np.zeros((n, m)) 初始化全零矩阵 K = np.zeros((5,5)) np.linspace(a, b, n) 生成等差数列 网格节点生成 enumerate(list) 遍历列表同时获取索引 for i, val in enumerate(nodes): array[-1] 索引倒数第一个元素 获取末端节点 array.copy() 深拷贝 K_bc = K.copy() (直接赋值是引用，修改会影响原数组) np.linalg.solve 解线性方程组 x = solve(A, b) (内部使用 LAPACK，高效) ","permalink":"https://example.org/posts/1d%E6%9C%89%E9%99%90%E5%85%83python%E7%A8%8B%E5%BA%8F%E5%A4%8D%E5%BB%BA%E4%B8%8E%E6%B3%A8%E8%A7%A3/","summary":"\u003ch2 id=\"1-问题定义与物理模型\"\u003e1. 问题定义与物理模型\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e目标\u003c/strong\u003e：求解一根长度为 $L$、弹性模量为 $E$、横截面积 $A(x)$ 随位置变化的杆件，在右端受到拉力 $P$ 作用下的位移场 $u(x)$。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e控制方程 (Strong Form)\u003c/strong\u003e：\n\u003c/p\u003e\n$$\n\\frac{d}{dx}\\left( E A(x) \\frac{du}{dx} \\right) = 0, \\quad x \\in [0, L]\n$$\u003cp\u003e\n\u003cstrong\u003e边界条件\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDirichlet (本质边界): $u(0) = 0$ (左端固定)\u003c/li\u003e\n\u003cli\u003eNeumann (自然边界): $E A(L) \\frac{du}{dx}|_{x=L} = P$ (右端受力)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e有限元离散 (Weak Form)\u003c/strong\u003e：\n对于线性杆单元，单元刚度矩阵 $k_e$ 为：\n\u003c/p\u003e\n$$\nk_e = \\frac{EA_{avg}}{L_e} \\begin{bmatrix} 1 \u0026 -1 \\\\ -1 \u0026 1 \\end{bmatrix}\n$$\u003cp\u003e\n其中 $A_{avg}$ 取单元中心处的截面面积近似。\u003c/p\u003e\n\u003ch2 id=\"2-代码实现架构\"\u003e2. 代码实现架构\u003c/h2\u003e\n\u003cp\u003e程序整体分为五个模块：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e前处理 (Pre-processing)\u003c/strong\u003e: 离散化几何域，生成节点与单元。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e单元计算 (Element Calculation)\u003c/strong\u003e: 计算局部刚度矩阵。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e组装 (Assembly)\u003c/strong\u003e: 构建全局刚度矩阵 $K$ 和载荷向量 $F$。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e边界处理 (Boundary Conditions)\u003c/strong\u003e: 修正矩阵以引入约束。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e求解与可视化 (Solver \u0026amp; Post-processing)\u003c/strong\u003e: 解方程组并绘图。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"21-初始化与参数定义\"\u003e2.1 初始化与参数定义\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e plt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# === 物理参数 ===\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eL_total \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10.0\u003c/span\u003e      \u003cspan style=\"color:#75715e\"\u003e# 杆件总长度 [m]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eP_load  \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1000.0\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e# 末端拉力 [N]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eE_mod   \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2.1e11\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e# 弹性模量 [Pa]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# === 几何参数 (变截面模拟) ===\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eget_area\u003c/span\u003e(x):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    定义横截面积 A 随坐标 x 的变化函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    此处模拟锥形杆: 根部 0.01 m^2 -\u0026gt; 末端 0.005 m^2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0.01\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e (\u003cspan style=\"color:#ae81ff\"\u003e0.005\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e x \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e L_total)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# === 网格控制 ===\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNUM_ELEMENTS \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e                  \u003cspan style=\"color:#75715e\"\u003e# 单元数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNUM_NODES    \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e NUM_ELEMENTS \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e# 节点数量 (1D线性单元)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"22-网格生成-meshing\"\u003e2.2 网格生成 (Meshing)\u003c/h3\u003e\n\r\n\r\n\r\n\r\n  \u003cblockquote\u003e\r\n    \u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNodes (Coordinates)\u003c/strong\u003e: 存储物理坐标。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConnectivity (Topology)\u003c/strong\u003e: 存储节点间的连接关系。对于 1D 线性单元，第 $i$ 个单元连接节点 $i$ 和 $i+1$。\u003c/li\u003e\n\u003c/ul\u003e\r\n  \u003c/blockquote\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 1. 生成节点坐标数组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# linspace: 生成等间距分布的节点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enodes \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003elinspace(\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, L_total, NUM_NODES)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 2. 生成单元连接表 (Connectivity Matrix)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# elements[i] = [左节点索引, 右节点索引]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eelements \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e range(NUM_ELEMENTS):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    elements\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eappend([i, i \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 转为 array 方便后续索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eelements \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003earray(elements)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n\r\n\r\n\r\n  \u003cblockquote\u003e\r\n    \u003cp\u003e\u003ccode\u003enp.linspace(start, stop, num)\u003c/code\u003e 生成包含 \u003ccode\u003enum\u003c/code\u003e 个点的等差数列（闭区间）。这是 FEM 生成结构化网格最常用的函数。\u003c/p\u003e","title":"FEM 复习：1D 变截面杆件分析 (Python 实现)"},{"content":"tags: #有限元 #虚位移原理\n1.虚位移原理 1.1 什么是虚位移 虚位移通常使用 $\\delta u$来进行表示\n微小变动且为假想 满足几何约束条件 发生时不经过时间 2.1 虚位移原理的基本表述 如果一个变形体处于静力平衡状态，那么对于任意满足位移边界条件的微小虚位移 $\\delta u$，作用在物体上的真实外力所做的==“外虚功”==，必等于物体内部真实应力所做的==“内虚功”==。 $$\\delta u W_{ext}=\\delta u W_{in t}$$ 采用一个基本的线性杆虚位移变形过程\n外力功: $$\\delta W_{ext} = \\int_{0}^{L} b(x) \\cdot \\delta u(x) \\, dx + P \\cdot \\delta u(L)$$\r其中$b(x)$为体力关于$x$的函数,P为合外力\n内力功:\n杆件内部的真实应力$\\sigma$在虚应变$\\epsilon$上做的功（本质为虚应变能） 真实应力 $\\sigma=E\\epsilon=E \\frac{du}{dx}$ 虚应变 $\\epsilon= \\frac{d(\\delta u)}{dx}=$ 于是有内虚功为: $$\\delta W_{int} = \\int_{0}^{L} \\left( E \\frac{du}{dx} \\right) \\cdot \\left( \\frac{d(\\delta u)}{dx} \\right) \\cdot A(x) \\, dx$$","permalink":"https://example.org/posts/%E8%99%9A%E4%BD%8D%E7%A7%BB%E5%8E%9F%E7%90%86%E5%9C%A8%E6%9C%89%E9%99%90%E5%85%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"\u003cp\u003etags: #有限元 #虚位移原理\u003c/p\u003e\n\u003ch1 id=\"1虚位移原理\"\u003e1.虚位移原理\u003c/h1\u003e\n\u003ch2 id=\"11-什么是虚位移\"\u003e1.1 什么是虚位移\u003c/h2\u003e\n\u003cp\u003e虚位移通常使用 $\\delta u$来进行表示\u003c/p\u003e\n\r\n\r\n\r\n\r\n  \u003cblockquote\u003e\r\n    \u003cul\u003e\n\u003cli\u003e微小变动且为假想\u003c/li\u003e\n\u003cli\u003e满足几何约束条件\u003c/li\u003e\n\u003cli\u003e发生时不经过时间\u003c/li\u003e\n\u003c/ul\u003e\r\n  \u003c/blockquote\u003e\r\n\u003ch2 id=\"21-虚位移原理的基本表述\"\u003e2.1 虚位移原理的基本表述\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e如果一个变形体处于静力平衡状态，那么对于任意满足位移边界条件的微小虚位移 $\\delta u$，作用在物体上的真实外力所做的==“外虚功”==，必等于物体内部真实应力所做的==“内虚功”==。\u003c/strong\u003e\n\u003c/p\u003e\n$$\\delta u W_{ext}=\\delta u W_{in t}$$\u003cp\u003e\n采用一个基本的线性杆虚位移变形过程\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e外力功:\u003c/strong\u003e\n\u003c/p\u003e\n$$\\delta W_{ext} = \\int_{0}^{L} b(x) \\cdot \\delta u(x) \\, dx + P \\cdot \\delta u(L)$$\r\n\r\n\r\n\r\n  \u003cblockquote\u003e\r\n    \u003cp\u003e其中$b(x)$为体力关于$x$的函数,P为合外力\u003c/p\u003e\n\r\n  \u003c/blockquote\u003e\r\n\u003cp\u003e\u003cstrong\u003e内力功:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e杆件内部的真实应力$\\sigma$在虚应变$\\epsilon$上做的功（本质为虚应变能）\n真实应力 $\\sigma=E\\epsilon=E \\frac{du}{dx}$ 虚应变 $\\epsilon= \\frac{d(\\delta u)}{dx}=$ 于是有内虚功为:\n\u003c/p\u003e\n$$\\delta W_{int} = \\int_{0}^{L} \\left( E \\frac{du}{dx} \\right) \\cdot \\left( \\frac{d(\\delta u)}{dx} \\right) \\cdot A(x) \\, dx$$","title":"虚位移原理在有限元中的应用"}]